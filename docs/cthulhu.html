
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cthulhu &#8212; LabGraph  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Module Lifecycle" href="lifecycles-and-configuration.html" />
    <link rel="prev" title="C++ Interoperability" href="cpp-interop.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="cthulhu">
<h1>Cthulhu<a class="headerlink" href="#cthulhu" title="Permalink to this headline">¶</a></h1>
<p>Cthulhu is a flexible real-time streaming and synchronization framework.</p>
<div class="section" id="what-is-cthulhu">
<h2>What is Cthulhu?<a class="headerlink" href="#what-is-cthulhu" title="Permalink to this headline">¶</a></h2>
<p>Cthulhu is a C++ library with minimal software dependencies. It provides an API for building low-latency processing graphs using standardized and customizable stream types.</p>
<p>So, it’s a pub/sub framework, why not just use <other framework>?</p>
<ol class="arabic simple">
<li><p>Cthulhu’s API enables explicit construction of a graphical flow of data. Think of pub/sub as the single-input or single-output cases, whereas Cthulhu enables multi-input-multi-output (MIMO) compute tasks. This enables the framework to automatically track the flow of individual samples through the pipeline, and produce end-to-end historical latency tracking of any sample. In the future, it may also provide a convenient API for dynamic flow control within the graph.</p></li>
<li><p>Typical pub/sub frameworks focus on distributed socket-based communication. For systems with light-weight metadata streams, this works just fine. But with perception systems, we often use high-bandwidth data on our stream interfaces. Cthulhu allocates and recycles data buffers from shared memory, and exposes them to the user as ordinary shared pointer to enable transparent low-latency IPC to consumers that live in other processes on the same machine.</p></li>
</ol>
<p>Cthulhu is currently supported on Windows, Mac, Linux, and Android.</p>
</div>
<div class="section" id="why-should-i-care">
<h2>Why should I care?<a class="headerlink" href="#why-should-i-care" title="Permalink to this headline">¶</a></h2>
<p>Cthulhu enables tooling and infrastructure reuse across real-time pipelines, and modularity for reuse of subcomponents. For a user that builds a new pipeline using entirely existing stream types and compute functions, all tooling comes for free.</p>
</div>
<div class="section" id="streams">
<h2>Streams<a class="headerlink" href="#streams" title="Permalink to this headline">¶</a></h2>
<p>To use Cthulhu, first you must define the layout of your streaming data. Cthulhu comes packaged with a few fundamental types such as image and audio streams, but provides an API for users to register their own types without modification to the Cthulhu library.</p>
<p>A sample of a stream has 4 components:</p>
<ul class="simple">
<li><p>Header - Unique identifying information.</p>
<ul>
<li><p>Timestamp</p></li>
<li><p>Sequence</p></li>
</ul>
</li>
<li><p>ProcessingTimestamp(s) [Optional] - It is possible to tag a sample with timestamps that are associated with stages in the processing chain at which it was developed. An example would be the time at which an image was received in user-space software from a camera device.</p></li>
<li><p>Content Block [Optional] - This is variable size bulk data. Think of it as the pixel data in an image. The size of the block must be derivable from the Config Fields (more on that later). This block can also be broken out into a set of sub-samples that is specified by an additional field. By default, the block is composed of a single sub-sample.</p></li>
<li><p>Sample Field(s) [Optional] - These are light-weight fixed-size fields. Each field is named, and must be POD.</p></li>
</ul>
<p>A user can define a sample format by inheriting from cthulhu::AutoStreamSample:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ImageData</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AutoStreamSample</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">T</span> <span class="o">=</span> <span class="n">ImageData</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// We are free to name each parameter as desired</span>
  <span class="n">HeaderTimestamp</span> <span class="n">captureTimestamp</span><span class="p">{</span><span class="k">this</span><span class="p">};</span>
  <span class="n">HeaderSequence</span> <span class="n">frameNumber</span><span class="p">{</span><span class="k">this</span><span class="p">};</span>

  <span class="c1">// Define the name which the processing stamp will be given</span>
  <span class="n">ProcessingTimestamp</span> <span class="n">arrivalTimestamp</span><span class="p">{</span><span class="s">&quot;arrival&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">};</span>

  <span class="c1">// If we want a Content Block, just add one with any parameter name.</span>
  <span class="n">ContentBlock</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">{</span><span class="k">this</span><span class="p">};</span>

  <span class="c1">// All fields must be sandwiched between a FieldsBegin and FieldsEnd</span>
  <span class="n">FieldsBegin</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">begin</span><span class="p">;</span>
  <span class="c1">// Define the type (here uint32_t),</span>
  <span class="n">SampleField</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">strideInBytes</span><span class="p">{</span><span class="s">&quot;image_stride&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">};</span>
  <span class="n">SampleField</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">offsetInBytes</span><span class="p">{</span><span class="s">&quot;offset&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">};</span>
  <span class="n">FieldsEnd</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">end</span><span class="p">;</span>

  <span class="c1">// This must be called as public, and takes the class name as argument</span>
  <span class="n">CTHULHU_AUTOSTREAM_SAMPLE</span><span class="p">(</span><span class="n">ImageData</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If a stream has no Content Block, it is called a “Basic Stream.” And your journey ends here. Put this in a header, and call the basic registration function from the corresponding cpp source file:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CTHULHU_REGISTER_BASIC_STREAM_TYPE</span><span class="p">(</span><span class="n">Image</span><span class="p">,</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="p">);</span>
</pre></div>
</div>
<p>This registers the type to the identified “Image”, which must be unique across all actively communicating Cthulhu runtimes.</p>
<p>If your stream includes a Content Block, it must also provide a Configuration which can be used to configure the Stream’s Content Block format. This is similar to the Sample definition, but has the following components:</p>
<ul class="simple">
<li><p>Compute Sample Size Function - This function must return the size of the Content Block being actively streamed. If the block is broken into sub-samples, it is the size of a single sub-sample.</p></li>
<li><p>Sample Rate [Optional] - This is the nominal rate of samples being streamed.</p></li>
<li><p>Config Field(s) - Similar to Sample Fields, but at least one field is required for use in the Compute Sample Size Function.</p></li>
</ul>
<p>Here is an example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">PixelFormat</span> <span class="o">:</span> <span class="kt">uint32_t</span> <span class="p">{</span> <span class="n">INVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MONO_8</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MONO_10</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">YUY2</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">COUNT</span> <span class="p">};</span>

<span class="k">class</span> <span class="nc">ImageFormat</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AutoStreamConfig</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">T</span> <span class="o">=</span> <span class="n">ImageFormat</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">SampleRate</span> <span class="n">nominalSampleRate</span><span class="p">{</span><span class="k">this</span><span class="p">};</span>

  <span class="n">FieldsBegin</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">begin</span><span class="p">;</span>
  <span class="n">ConfigField</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">width</span><span class="p">{</span><span class="s">&quot;image_width&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">};</span>
  <span class="n">ConfigField</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">height</span><span class="p">{</span><span class="s">&quot;image_height&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">};</span>
  <span class="n">ConfigField</span><span class="o">&lt;</span><span class="n">PixelFormat</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">pixelFormat</span><span class="p">{</span><span class="s">&quot;pixel_format&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">};</span>
  <span class="n">FieldsEnd</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">end</span><span class="p">;</span>

 <span class="c1">// This is the pure-virtual function that must be overridden</span>
  <span class="kr">inline</span> <span class="k">virtual</span> <span class="kt">uint32_t</span> <span class="nf">computeSampleSize</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">pixelFormat</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="n">PixelFormat</span><span class="o">::</span><span class="nl">MONO_8</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
      <span class="k">case</span> <span class="n">PixelFormat</span><span class="o">::</span><span class="nl">MONO_10</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
      <span class="k">case</span> <span class="n">PixelFormat</span><span class="o">::</span><span class="nl">YUY2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2U</span> <span class="o">*</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
      <span class="k">default</span><span class="o">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">};</span>

  <span class="n">CTHULHU_AUTOSTREAM_CONFIG</span><span class="p">(</span><span class="n">ImageFormat</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This stream can then be registered as an ordinary stream type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CTHULHU_REGISTER_STREAM_TYPE</span><span class="p">(</span><span class="n">Image</span><span class="p">,</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="p">,</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageFormat</span><span class="p">);</span>
</pre></div>
</div>
<p>If a stream type is registered in a static library, it is important to ensure that symbols required for type registration get linked into the final executable. Using BUCK, these libraries should set <code class="docutils literal notranslate"><span class="pre">link_whole</span> <span class="pre">=</span> <span class="pre">True</span></code>.</p>
<p>To work with the components of the streams, such as ConfigFields, they come with set()/get() functions, and also overload operator=() for convenience. So you can access them just like you would an ordinary data field. Underneath the hood, these types are just thin wrappers over a single generic StreamSample data structure object. This enables the framework to cast between typed and untyped data with minimal overhead, while providing regularized structure to the untyped data that allows it to work its magic without embedding the data in an additional container.</p>
<p>You may ask: but what if I need multiple content blocks in my stream? The answer is, you don’t. If you need an additional content block, then you need an additional stream. Cthulhu’s APIs make it just as easy and performant to work with multiple streams instead of just one, so your system will thank you for the modularity of splitting out the data.</p>
</div>
<div class="section" id="nodes">
<h2>Nodes<a class="headerlink" href="#nodes" title="Permalink to this headline">¶</a></h2>
<p>Nodes are a logical unit of compute within the pipeline which receives N data streams in to produce M data streams out. Cthulhu provides an API for convenient construction of Nodes.</p>
<p>Here’s an example of the most basic pub/sub behavior using a “Basic” stream type with sample type BasicSample:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cthulhu</span><span class="o">::</span><span class="n">Context</span> <span class="n">myContext</span><span class="p">(</span><span class="s">&quot;my_context&quot;</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">BasicSample</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">cb</span> <span class="o">=</span>
      <span class="p">[](</span><span class="k">const</span> <span class="n">BasicSample</span><span class="o">&amp;</span> <span class="n">sample</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{};</span>
<span class="k">auto</span> <span class="n">subscriber</span> <span class="o">=</span> <span class="n">myContext</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="s">&quot;stream_name&quot;</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">publisher</span> <span class="o">=</span> <span class="n">myContext</span><span class="p">.</span><span class="n">advertise</span><span class="o">&lt;</span><span class="n">BasicSampleType</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;stream_name&quot;</span><span class="p">);</span>
<span class="n">BasicSampleType</span> <span class="n">mySample</span><span class="p">;</span>
<span class="n">publish</span><span class="p">.</span><span class="n">publish</span><span class="p">(</span><span class="n">mySample</span><span class="p">);</span>
</pre></div>
</div>
<p>Since both the producer and the consumer in this example are in the same process, underneath the hood the call to publish() is directly calling the callback “cb” without any queueing or additional threads. This is great for cases where consumers are super-light-weight processing that have minimal penalty in injecting their function directly in the producer’s thread since the data will reach the consumer with the least latency.</p>
<p>But what if we had a heavy consuming function that needed its own thread or would otherwise slow down the consumer? That’s what SubscriberOptions are for. We can call subscribe() with an additional options parameter which sets the ConsumerType to ASYNC. This will cause the subscriber to dedicate its own thread for processing its callback function. In this case, the publish() call will now push mySample to an async queue and notify the subscriber’s thread.</p>
<p>For usage of only single input or single output Nodes and basic stream types, this API looks a lot like basic pub/sub. Next, let’s explore how we use an ordinary stream that uses both Config and Samples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Subscribers must now specify two callbacks, one for sample and one for config</span>
<span class="c1">// The config callback returns bool. With</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">cb</span> <span class="o">=</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="o">&amp;</span> <span class="n">image</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span> <span class="n">callback_executed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageFormat</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">configCb</span> <span class="o">=</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageFormat</span><span class="o">&amp;</span> <span class="n">format</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">auto</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="s">&quot;image&quot;</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">configCb</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">pub</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">advertise</span><span class="o">&lt;</span><span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;image&quot;</span><span class="p">);</span>

<span class="c1">// We must configure our stream before we publish any samples on it!</span>
<span class="c1">// The config must produce a valid return value of computeSampleSize(), so here we set</span>
<span class="c1">// the height and width of the image to something valid</span>
<span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageFormat</span> <span class="n">format</span><span class="p">;</span>
<span class="n">format</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">640</span><span class="p">;</span>
<span class="n">format</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">480</span><span class="p">;</span>
<span class="n">format</span><span class="p">.</span><span class="n">pixelFormat</span> <span class="o">=</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">PixelFormat</span><span class="o">::</span><span class="n">MONO_8</span><span class="p">;</span>
<span class="n">pub</span><span class="o">-&gt;</span><span class="n">configure</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>

<span class="c1">// We must use our publisher to allocate our sample data!</span>
<span class="c1">// This will leverage the current config of the stream, which is a 640 x 480 image</span>
<span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span> <span class="n">image</span> <span class="o">=</span> <span class="n">pub</span><span class="o">-&gt;</span><span class="n">allocateSample</span><span class="o">&lt;</span><span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">pub</span><span class="o">-&gt;</span><span class="n">publish</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
</pre></div>
</div>
<p>The difference here is that we now have 2 callbacks, and must call configure() before any calls to publish() on the stream. The Sample must also be allocated using the publisher since it has a Content Block.</p>
<p>Calls to publish() and configure() are not thread safe. Thus, you should only push data to a producing Node on a single thread. Conversely, the config and sample callbacks do not need to handle thread safety. The user can assume that the two types of callbacks will only come from a single thread.</p>
<p>So far, we’ve only explored single input and single output Nodes. Next, let’s look at a Transformer with both an input and an output:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">cb</span> <span class="o">=</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="o">&amp;</span> <span class="n">image</span><span class="p">,</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="o">&amp;</span> <span class="n">imageOut</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageFormat</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageFormat</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">configCb</span> <span class="o">=</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageFormat</span><span class="o">&amp;</span> <span class="n">format</span><span class="p">,</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageFormat</span><span class="o">&amp;</span> <span class="n">formatOut</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="n">formatOut</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">640</span><span class="p">;</span>
  <span class="n">formatOut</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">480</span><span class="p">;</span>
  <span class="n">formatOut</span><span class="p">.</span><span class="n">pixelFormat</span> <span class="o">=</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">PixelFormat</span><span class="o">::</span><span class="n">MONO_8</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">auto</span> <span class="n">trans</span> <span class="o">=</span>
    <span class="n">context</span><span class="p">.</span><span class="n">transform</span><span class="o">&lt;</span><span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="p">,</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;image1&quot;</span><span class="p">,</span> <span class="s">&quot;image2&quot;</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">config_cb</span><span class="p">);</span>
</pre></div>
</div>
<p>This should look like a mix between the Publisher and Subscriber, because it is. The main difference is that the user is not responsible for allocating its output samples, as the framework will provide it to the callback pre-allocated. Configuring the output stream also happens within the callback to the configuration of the input stream. In many cases, the two configurations may be un-related, but this gives the flexibility in allowing the user to tie the two together. For example, an RGB to Grayscale transformer would maintain the height/width of the original image and expect the input pixel format to be RGB.</p>
<p>Similar to Subscriber, this can be given TransformerOptions optionally to specify ASYNC mode.</p>
<p>Finally, the most complex case of multi-input, multi-output, here is an example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">cb</span> <span class="o">=</span>
    <span class="p">[](</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="o">&gt;&amp;</span> <span class="n">imagesIn</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageData</span><span class="o">&gt;&amp;</span> <span class="n">imagesOut</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageFormat</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageFormat</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="n">configCb</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageFormat</span><span class="o">&gt;&amp;</span> <span class="n">imagesIn</span><span class="p">,</span>
                  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cthulhu</span><span class="o">::</span><span class="n">ImageFormat</span><span class="o">&gt;&amp;</span> <span class="n">imagesOut</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">};</span>
<span class="n">cthulhu</span><span class="o">::</span><span class="n">MultiTransformer</span> <span class="n">trans</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span>
    <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cthulhu</span><span class="o">::</span><span class="n">StreamID</span><span class="o">&gt;</span><span class="p">{</span><span class="s">&quot;image1&quot;</span><span class="p">,</span> <span class="s">&quot;image2&quot;</span><span class="p">}},</span>
    <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cthulhu</span><span class="o">::</span><span class="n">StreamID</span><span class="o">&gt;</span><span class="p">{</span><span class="s">&quot;image3&quot;</span><span class="p">}},</span>
    <span class="n">cb</span><span class="p">,</span>
    <span class="n">configCb</span><span class="p">);</span>
</pre></div>
</div>
<p>This should look just like the regular transformer, but now the input stream and output streams are lists of stream ID’s rather than single values. The callback arguments can also be grouped together with std::vector or std::array, which can be handy for cases where you have a large number of input or output streams of the same type.</p>
<p>Underneath the hood, Cthulhu is creating Producers and Consumers for each of these streams, and joining them together in an Aligner and a Dispatcher. The default Alignment behavior is based on timestamp matching with a max latency and tolerance threshold. The user can create their own variants of Aligner and pass them via MultiTransformerOptions (or MultiSubscriberOptions). This allows for customizable alignment behavior. Cthulhu comes packaged with an additional SubAligner implementation that can align the sub-samples of streams within a Content Block. This requires any stream using sub-samples to include a Sample Rate within its Config.</p>
</div>
<div class="section" id="clock">
<h2>Clock<a class="headerlink" href="#clock" title="Permalink to this headline">¶</a></h2>
<p>Cthulhu also provides a clock interface, useful for system simulation. A user should query time through cthulhu:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">time</span> <span class="o">=</span> <span class="n">cthulhu</span><span class="o">::</span><span class="n">clock</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getTime</span><span class="p">();</span>
</pre></div>
</div>
<p>By default, this will just return wall time. However, a single context name can be given clock authority to control time. This should be whichever context is being used to control the flow of data via Publishers.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Declare use of simulated time, with clock_owner as the context</span>
  <span class="n">cthulhu</span><span class="o">::</span><span class="n">ClockAuthority</span> <span class="n">fac</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="s">&quot;clock_owner&quot;</span><span class="p">);</span>

  <span class="p">...</span>

  <span class="c1">// This context can now control time</span>
  <span class="n">cthulhu</span><span class="o">::</span><span class="n">Context</span> <span class="n">owningContext</span><span class="p">(</span><span class="s">&quot;clock_owner&quot;</span><span class="p">);</span>
  <span class="n">owningContext</span><span class="p">.</span><span class="n">getClockControl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setTime</span><span class="p">(</span><span class="mf">500.0</span><span class="p">);</span>
  <span class="n">owningContext</span><span class="p">.</span><span class="n">getClockControl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">();</span>

  <span class="c1">// And this one cannot</span>
  <span class="n">cthulhu</span><span class="o">::</span><span class="n">Context</span> <span class="n">otherContext</span><span class="p">(</span><span class="s">&quot;some_context&quot;</span><span class="p">);</span>
  <span class="n">otherContext</span><span class="p">.</span><span class="n">getClockControl</span><span class="p">();</span> <span class="c1">// Returns nullptr</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Listeners of the clock can subscribe to events, such as start, pause, etc.</p>
</div>
<div class="section" id="framework">
<h2>Framework<a class="headerlink" href="#framework" title="Permalink to this headline">¶</a></h2>
<p>All of the above is sufficient for most users of Cthulhu to accomplish their goal. However, these functionalities under the hood are using the Cthulhu Framework Singleton to achieve their goals. The Framework has 4 components:</p>
<ul class="simple">
<li><p>TypeRegistry - Provides access to information about stream types that have been registered. E.g. names of fields, basic flag, sizes, etc.</p></li>
<li><p>StreamRegistry - Provides access to stream interfaces on which data can be propagated (using raw StreamConfig and StreamSample’s)</p></li>
<li><p>MemoryPool - Allocates recyclable data buffers (from local memory, shared memory, etc)</p></li>
<li><p>ClockManager - Manages the state of the clock, and access to its controls</p></li>
</ul>
<p>Currently, the default implementation of Framework is called “IPCHybrid.” This implementation uses a mix of managed shared memory and local memory to achieve its goals with minimal latency. Thus, interactions between nodes in the same process don’t have to go through shared memory and callbacks are executed directly. The CTHULHU_IPC compiler flag will set this, and removal of the flag will compile against a “Local” implementation of Framework that is restricted to a single process.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">LabGraph</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="messages.html">Messages</a></li>
<li class="toctree-l1"><a class="reference internal" href="concepts.html">LabGraph Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpp-interop.html">C++ Interoperability</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Cthulhu</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-is-cthulhu">What is Cthulhu?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#why-should-i-care">Why should I care?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#streams">Streams</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nodes">Nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#clock">Clock</a></li>
<li class="toctree-l2"><a class="reference internal" href="#framework">Framework</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lifecycles-and-configuration.html">Module Lifecycle</a></li>
<li class="toctree-l1"><a class="reference internal" href="lifecycles-and-configuration.html#configuration">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="websockets-api-errors.html">WebSockets API Error Codes</a></li>
<li class="toctree-l1"><a class="reference internal" href="websockets-api.html">WebSockets API</a></li>
<li class="toctree-l1"><a class="reference internal" href="zmq-support.html">ZMQ Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="performance/realtime-streaming-performance.html">Real-Time Streaming Performance in LabGraph &amp; Cthulhu</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation/macos.html">MacOS Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/codetools/README.html">Use Flake8 for styling checks</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="cpp-interop.html" title="previous chapter">C++ Interoperability</a></li>
      <li>Next: <a href="lifecycles-and-configuration.html" title="next chapter">Module Lifecycle</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2004 - present Facebook. All Rights Reserved..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/docs/cthulhu.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>